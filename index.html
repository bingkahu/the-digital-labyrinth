<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Digital Labyrinth â€” GitHub Pages Edition</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #171a2b;
      --accent: #6c8cff;
      --accent2: #ff7a59;
      --text: #e6e9ff;
      --muted: #aab0d6;
      --success: #3ecf8e;
      --danger: #ff5c5c;
      --gold: #ffd166;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans';
      background: radial-gradient(1200px 600px at 20% 0%, #12152a 0%, var(--bg) 60%);
      color: var(--text);
    }
    .header {
      padding: 1.5rem 1rem;
      text-align: center;
      background: linear-gradient(180deg, rgba(108,140,255,0.15), transparent);
    }
    .header h1 { margin: 0 0 0.5rem; font-size: 2rem; }
    .header p { margin: 0; color: var(--muted); }
    .banner {
      margin-top: 0.75rem;
      display: inline-block;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
    }
    .container { max-width: 1100px; margin: 0 auto; padding: 1rem; }
    .panel {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .panel h2 { margin-top: 0; font-size: 1.25rem; color: var(--accent); }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 0.75rem; align-items: center; }
    label span { display: inline-block; margin-bottom: 0.25rem; color: var(--muted); }
    input, select, button {
      width: 100%; padding: 0.6rem 0.7rem; border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.12); background: #0f1324; color: var(--text);
      outline: none;
    }
    button {
      cursor: pointer; background: linear-gradient(180deg, #1b2140, #12162e);
      border: 1px solid rgba(108,140,255,0.35);
    }
    button:hover { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(108,140,255,0.15); }
    .status-row > div {
      background: #0f1324; padding: 0.6rem 0.7rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.08);
    }
    .progress, .energy {
      margin-top: 0.75rem; background: #0b0e1d; border: 1px solid rgba(255,255,255,0.08);
      border-radius: 999px; height: 16px; overflow: hidden;
    }
    .progress-bar, .energy-bar {
      height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.2s ease;
    }
    .energy-bar { background: linear-gradient(90deg, var(--success), var(--danger)); }
    .message { margin-top: 0.75rem; padding: 0.6rem 0.7rem; border-radius: 8px; background: #0f1324; border: 1px solid rgba(255,255,255,0.08); min-height: 2.2rem; }
    .board {
      position: relative; margin-top: 1rem; background: #0b0e1d; border-radius: 12px; padding: 0.75rem; border: 1px solid rgba(255,255,255,0.08);
    }
    .track {
      display: grid; grid-template-columns: repeat(100, 1fr); gap: 2px; height: 40px;
    }
    .cell {
      background: #12162e; border-radius: 4px; position: relative; overflow: hidden;
    }
    .cell.goal { background: #1f2546; border: 1px solid rgba(255,255,255,0.12); }
    .avatar {
      position: absolute; top: -10px; left: 0; width: 100%; height: 60px;
      display: flex; align-items: center; justify-content: center;
      transition: transform 0.25s ease;
    }
    .avatar .dot {
      width: 20px; height: 20px; border-radius: 50%; background: var(--gold); box-shadow: 0 0 12px rgba(255,209,102,0.6);
    }
    .badges { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
    .badge {
      background: #0f1324; border: 1px solid rgba(255,255,255,0.08); border-radius: 999px; padding: 0.3rem 0.6rem; font-size: 0.85rem;
    }
    canvas { background: #0f1324; border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; }
    .footer { text-align: center; padding: 1rem; color: var(--muted); }
    @media (max-width: 700px) {
      .track { height: 60px; }
      .avatar .dot { width: 16px; height: 16px; }
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>Digital Labyrinth</h1>
    <p>Escape Room 100 before your energy runs out. Flip coins, test luck, and compare strategies.</p>
    <div class="banner">ðŸš€ GitHub Pages Edition â€” Shareable, reproducible, and optimized for demos</div>
  </header>

  <main class="container">
    <section class="panel">
      <h2>Game settings</h2>
      <div class="grid">
        <label><span>Rooms</span><input type="number" id="rooms" value="100" min="10" max="500" /></label>
        <label><span>Energy</span><input type="number" id="energy" value="5000" min="100" max="20000" /></label>
        <label><span>Mode</span>
          <select id="mode">
            <option value="mercy">Mercy Rule (Heads starts 50%, +1% after each reset)</option>
            <option value="fixed">Fixed 80% Heads, Tails sends you back 5 rooms</option>
            <option value="insane">Insane: Heads 60%, Tails teleports to random room</option>
          </select>
        </label>
        <label><span>Seed (optional)</span><input type="text" id="seed" placeholder="e.g., sheen-legend" /></label>
        <button id="newGame">New game</button>
        <button id="shareLink">Share run link</button>
      </div>
      <div class="badges" id="badges"></div>
    </section>

    <section class="panel">
      <h2>Controls</h2>
      <div class="grid">
        <button id="flipOnce">Flip once</button>
        <button id="autoRun">Auto-run</button>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
        <label><span>Speed</span><input type="range" id="speed" min="1" max="200" value="50" /></label>
      </div>
    </section>

    <section class="panel">
      <h2>Status</h2>
      <div class="grid status-row">
        <div><strong>Position:</strong> <span id="position">1</span> / <span id="roomsLabel">100</span></div>
        <div><strong>Energy:</strong> <span id="energyLeft">5000</span></div>
        <div><strong>Fails:</strong> <span id="fails">0</span></div>
        <div><strong>Heads %:</strong> <span id="pHeads">50%</span></div>
        <div><strong>Flips:</strong> <span id="flips">0</span></div>
        <div><strong>Longest Heads streak:</strong> <span id="streak">0</span></div>
      </div>
      <div class="progress"><div class="progress-bar" id="progressBar"></div></div>
      <div class="energy"><div class="energy-bar" id="energyBar"></div></div>
      <div id="message" class="message"></div>
    </section>

    <section class="panel board">
      <h2>Labyrinth board</h2>
      <div class="track" id="track"></div>
      <div class="avatar" id="avatar"><div class="dot"></div></div>
    </section>

    <section class="panel">
      <h2>Simulation</h2>
      <div class="grid">
        <label><span>Trials</span><input type="number" id="trials" value="1000" min="10" max="100000" /></label>
        <button id="runSim">Run simulation</button>
        <button id="stressTest">Run 10k stress test</button>
        <div><strong>Success rate:</strong> <span id="simSuccess">â€”</span></div>
        <div><strong>Average flips:</strong> <span id="simAvg">â€”</span></div>
        <div><strong>Median flips:</strong> <span id="simMedian">â€”</span></div>
      </div>
      <canvas id="histogram" width="800" height="220"></canvas>
    </section>

    <section class="panel">
      <h2>Mode comparison dashboard</h2>
      <button id="compareModes">Compare Mercy vs Fixed</button>
      <canvas id="compareChart" width="800" height="220"></canvas>
    </section>
  </main>

  <footer class="footer">
    <p>Built for GitHub Pages â€” share your run with URL params (rooms, energy, mode, seed).</p>
  </footer>

  <script>
    // Seeded RNG (Mulberry32)
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }
    function hashSeed(s) {
      let h = 0; for (let i = 0; i < s.length; i++) { h = (h << 5) - h + s.charCodeAt(i); h |= 0; }
      return h;
    }

    // Game logic
    class Labyrinth {
      constructor({ rooms = 100, energy = 5000, mode = "mercy", seed = null } = {}) {
        this.rooms = rooms;
        this.energyMax = energy;
        this.mode = mode;
        this.seed = seed;
        this.reset();
      }
      reset() {
        this.position = 1;
        this.energy = this.energyMax;
        this.fails = 0;
        this.flips = 0;
        this.done = false;
        this.win = false;
        this.longestStreak = 0;
        this.currentStreak = 0;
        this.rng = this.seed ? mulberry32(hashSeed(this.seed)) : Math.random;
      }
      get pHeads() {
        if (this.mode === "mercy") return Math.min(0.5 + 0.01 * this.fails, 1.0);
        if (this.mode === "fixed") return 0.8;
        if (this.mode === "insane") return 0.6;
        return 0.5;
      }
      step() {
        if (this.done) return;
        const p = this.pHeads;
        const r = this.seed ? this.rng() : Math.random();
        this.flips += 1;
        this.energy -= 1;

        if (r < p) {
          this.position += 1;
          this.currentStreak += 1;
          this.longestStreak = Math.max(this.longestStreak, this.currentStreak);
        } else {
          this.currentStreak = 0;
          if (this.mode === "mercy") {
            this.position = 1;
            this.fails += 1;
          } else if (this.mode === "fixed") {
            this.position = Math.max(1, this.position - 5);
          } else if (this.mode === "insane") {
            this.position = Math.floor(1 + (this.seed ? this.rng() : Math.random()) * this.rooms);
          } else {
            this.position = 1;
          }
        }

        if (this.position >= this.rooms) { this.done = true; this.win = true; }
        else if (this.energy <= 0) { this.done = true; this.win = false; }
      }
    }

    // Sounds (generated via WebAudio)
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function beep(freq = 880, duration = 0.08, type = "sine", gain = 0.03) {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g); g.connect(audioCtx.destination);
      osc.start();
      setTimeout(() => osc.stop(), duration * 1000);
    }
    function soundHeads() { beep(880, 0.06, "triangle", 0.04); }
    function soundTails() { beep(220, 0.08, "sawtooth", 0.05); }
    function soundWin() { beep(1200, 0.12, "square", 0.06); setTimeout(() => beep(1500, 0.12, "square", 0.06), 120); }

    // UI elements
    const els = {
      rooms: document.getElementById("rooms"),
      energy: document.getElementById("energy"),
      mode: document.getElementById("mode"),
      seed: document.getElementById("seed"),
      newGame: document.getElementById("newGame"),
      shareLink: document.getElementById("shareLink"),
      flipOnce: document.getElementById("flipOnce"),
      autoRun: document.getElementById("autoRun"),
      pause: document.getElementById("pause"),
      reset: document.getElementById("reset"),
      speed: document.getElementById("speed"),
      position: document.getElementById("position"),
      roomsLabel: document.getElementById("roomsLabel"),
      energyLeft: document.getElementById("energyLeft"),
      fails: document.getElementById("fails"),
      pHeads: document.getElementById("pHeads"),
      flips: document.getElementById("flips"),
      streak: document.getElementById("streak"),
      progressBar: document.getElementById("progressBar"),
      energyBar: document.getElementById("energyBar"),
      message: document.getElementById("message"),
      track: document.getElementById("track"),
      avatar: document.getElementById("avatar"),
      badges: document.getElementById("badges"),
      trials: document.getElementById("trials"),
      runSim: document.getElementById("runSim"),
      stressTest: document.getElementById("stressTest"),
      simSuccess: document.getElementById("simSuccess"),
      simAvg: document.getElementById("simAvg"),
      simMedian: document.getElementById("simMedian"),
      histogram: document.getElementById("histogram"),
      compareModes: document.getElementById("compareModes"),
      compareChart: document.getElementById("compareChart"),
    };

    // Board setup
    function buildTrack(rooms) {
      els.track.innerHTML = "";
      for (let i = 1; i <= rooms; i++) {
        const cell = document.createElement("div");
        cell.className = "cell" + (i === rooms ? " goal" : "");
        els.track.appendChild(cell);
      }
    }

    // Leaderboard (localStorage)
    const LB_KEY = "labyrinth_leaderboard_v1";
    function loadLB() {
      try { return JSON.parse(localStorage.getItem(LB_KEY)) || { fastest: null, fewestFails: null, longestStreak: null }; }
      catch { return { fastest: null, fewestFails: null, longestStreak: null }; }
    }
    function saveLB(lb) { localStorage.setItem(LB_KEY, JSON.stringify(lb)); }
    function updateBadges(lb) {
      els.badges.innerHTML = "";
      const mk = (label, value) => {
        const div = document.createElement("div");
        div.className = "badge";
        div.textContent = `${label}: ${value === null ? "â€”" : value}`;
        els.badges.appendChild(div);
      };
      mk("Fastest escape (flips)", lb.fastest);
      mk("Fewest fails", lb.fewestFails);
      mk("Longest Heads streak", lb.longestStreak);
    }

    // URL params
    function readParams() {
      const u = new URL(window.location.href);
      const rooms = parseInt(u.searchParams.get("rooms") || "100", 10);
      const energy = parseInt(u.searchParams.get("energy") || "5000", 10);
      const mode = u.searchParams.get("mode") || "mercy";
      const seed = u.searchParams.get("seed") || "";
      return { rooms, energy, mode, seed };
    }
    function writeParams({ rooms, energy, mode, seed }) {
      const u = new URL(window.location.href);
      u.searchParams.set("rooms", rooms);
      u.searchParams.set("energy", energy);
      u.searchParams.set("mode", mode);
      if (seed) u.searchParams.set("seed", seed); else u.searchParams.delete("seed");
      return u.toString();
    }

    // Game instance
    let game = new Labyrinth();
    let autoTimer = null;

    function formatPct(x) { return `${Math.round(x * 100)}%`; }

    function updateUI() {
      els.position.textContent = game.position;
      els.roomsLabel.textContent = game.rooms;
      els.energyLeft.textContent = game.energy;
      els.fails.textContent = game.fails;
      els.pHeads.textContent = formatPct(game.pHeads);
      els.flips.textContent = game.flips;
      els.streak.textContent = game.longestStreak;
      els.progressBar.style.width = `${(game.position / game.rooms) * 100}%`;
      els.energyBar.style.width = `${(game.energy / game.energyMax) * 100}%`;

      const cellWidth = els.track.getBoundingClientRect().width / game.rooms;
      els.avatar.style.transform = `translateX(${(game.position - 1) * (cellWidth + 2)}px)`;

      if (game.done) {
        if (game.win) {
          els.message.textContent = `Escaped! ðŸŽ‰ Reached Room ${game.rooms} in ${game.flips} flips with ${game.energy} energy left. Longest Heads streak: ${game.longestStreak}.`;
          els.message.style.borderColor = "rgba(62,207,142,0.6)";
        } else {
          els.message.textContent = `Energy depleted. âŒ You reached Room ${game.position} after ${game.flips} flips. Longest Heads streak: ${game.longestStreak}.`;
          els.message.style.borderColor = "rgba(255,92,92,0.6)";
        }
      } else {
        els.message.textContent = `Keep flippingâ€¦`;
        els.message.style.borderColor = "rgba(255,255,255,0.08)";
      }
    }

    function newGame() {
      const rooms = Math.max(10, Math.min(500, parseInt(els.rooms.value, 10) || 100));
      const energy = Math.max(100, Math.min(20000, parseInt(els.energy.value, 10) || 5000));
      const mode = els.mode.value;
      const seed = (els.seed.value || "").trim();

      game = new Labyrinth({ rooms, energy, mode, seed: seed || null });
      buildTrack(rooms);
      stopAuto();
      updateUI();
    }

    function flipOnce() {
      const before = game.position;
      game.step();
      const after = game.position;
      if (game.done && game.win) soundWin();
      else if (after > before) soundHeads();
      else soundTails();
      updateUI();
      if (game.done) {
        const lb = loadLB();
        lb.fastest = lb.fastest === null ? game.flips : Math.min(lb.fastest, game.flips);
        lb.fewestFails = lb.fewestFails === null ? game.fails : Math.min(lb.fewestFails, game.fails);
        lb.longestStreak = lb.longestStreak === null ? game.longestStreak : Math.max(lb.longestStreak, game.longestStreak);
        saveLB(lb);
        updateBadges(lb);
      }
    }

    function startAuto() {
      if (autoTimer) return;
      const tick = () => {
        if (game.done) { stopAuto(); updateUI(); return; }
        const before = game.position;
        game.step();
        const after = game.position;
        if (game.done && game.win) soundWin();
        else if (after > before) soundHeads();
        else soundTails();
        updateUI();
      };
      const interval = Math.max(1, 201 - parseInt(els.speed.value, 10));
      autoTimer = setInterval(tick, interval);
    }
    function stopAuto() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }
    function resetGame() { game.reset(); stopAuto(); updateUI(); }

    // Simulation
    function runTrials(trials, config) {
      const flips = [];
      let success = 0;
      for (let i = 0; i < trials; i++) {
        const sim = new Labyrinth(config);
        while (!sim.done) sim.step();
        flips.push(sim.flips);
        if (sim.win) success += 1;
      }
      flips.sort((a, b) => a - b);
      const avg = flips.reduce((s, x) => s + x, 0) / flips.length;
      const median = flips[Math.floor(flips.length / 2)];
      return { successRate: success / trials, avgFlips: avg, medianFlips: median, flips };
    }
    function drawHistogram(canvas, data, bins = 30) {
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const min = Math.min(...data), max = Math.max(...data);
      const width = max - min || 1, binSize = width / bins;
      const counts = new Array(bins).fill(0);
      data.forEach(x => { const idx = Math.min(bins - 1, Math.floor((x - min) / binSize)); counts[idx] += 1; });
      const maxCount = Math.max(...counts) || 1;
      const w = canvas.width, h = canvas.height, barW = (w - 60) / bins;

      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.beginPath(); ctx.moveTo(40, h - 20); ctx.lineTo(w - 10, h - 20); ctx.moveTo(40, h - 20); ctx.lineTo(40, 10); ctx.stroke();

      for (let i = 0; i < bins; i++) {
        const x = 40 + i * barW;
        const barH = ((counts[i] / maxCount) * (h - 40));
        ctx.fillStyle = i < bins * 0.7 ? "#6c8cff" : "#ff7a59";
        ctx.fillRect(x, h - 20 - barH, barW - 2, barH);
      }
      ctx.fillStyle = "#aab0d6"; ctx.font = "12px system-ui";
      ctx.fillText(`Flips distribution (${bins} bins)`, 50, 20);
      ctx.fillText(`Min: ${min}`, 50, 36);
      ctx.fillText(`Max: ${max}`, 140, 36);
    }
    function compareModesDashboard() {
      const configBase = {
        rooms: Math.max(10, Math.min(500, parseInt(els.rooms.value, 10) || 100)),
        energy: Math.max(100, Math.min(20000, parseInt(els.energy.value, 10) || 5000)),
        seed: null,
      };
      const trials = 1000;
      const mercy = runTrials(trials, { ...configBase, mode: "mercy" });
      const fixed = runTrials(trials, { ...configBase, mode: "fixed" });

      const ctx = els.compareChart.getContext("2d");
      ctx.clearRect(0, 0, els.compareChart.width, els.compareChart.height);
      const w = els.compareChart.width, h = els.compareChart.height;

      // Axes
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.beginPath(); ctx.moveTo(40, h - 20); ctx.lineTo(w - 10, h - 20); ctx.moveTo(40, h - 20); ctx.lineTo(40, 10); ctx.stroke();

      // Bars
      const labels = ["Success %", "Avg flips", "Median flips"];
      const mercyVals = [mercy.successRate * 100, mercy.avgFlips, mercy.medianFlips];
      const fixedVals = [fixed.successRate * 100, fixed.avgFlips, fixed.medianFlips];
      const maxVal = Math.max(...mercyVals, ...fixedVals);
      const barW = (w - 80) / (labels.length * 2 + labels.length);
      let x = 50;

      labels.forEach((lab, i) => {
        // Mercy
        const mH = (mercyVals[i] / maxVal) * (h - 60);
        ctx.fillStyle = "#6c8cff";
        ctx.fillRect(x, h - 20 - mH, barW, mH);
        // Fixed
        const fH = (fixedVals[i] / maxVal) * (h - 60);
        ctx.fillStyle = "#ff7a59";
        ctx.fillRect(x + barW + 6, h - 20 - fH, barW, fH);

        ctx.fillStyle = "#aab0d6"; ctx.font = "12px system-ui";
        ctx.fillText(lab, x, h - 24);
        x += barW * 2 + 30;
      });
    }

    // Event bindings
    els.newGame.addEventListener("click", newGame);
    els.flipOnce.addEventListener("click", flipOnce);
    els.autoRun.addEventListener("click", startAuto);
    els.pause.addEventListener("click", stopAuto);
    els.reset.addEventListener("click", resetGame);
    els.runSim.addEventListener("click", () => {
      const trials = Math.max(10, Math.min(100000, parseInt(els.trials.value, 10) || 1000));
      const config = {
        rooms: Math.max(10, Math.min(500, parseInt(els.rooms.value, 10) || 100)),
        energy: Math.max(100, Math.min(20000, parseInt(els.energy.value, 10) || 5000)),
        mode: els.mode.value,
      };
      const { successRate, avgFlips, medianFlips, flips } = runTrials(trials, config);
      els.simSuccess.textContent = `${(successRate * 100).toFixed(2)}%`;
      els.simAvg.textContent = `${avgFlips.toFixed(2)}`;
      els.simMedian.textContent = `${medianFlips}`;
      drawHistogram(els.histogram, flips, 30);
    });
    els.stressTest.addEventListener("click", () => {
      els.trials.value = 10000;
      els.runSim.click();
    });
    els.compareModes.addEventListener("click", compareModesDashboard);
    els.shareLink.addEventListener("click", () => {
      const url = writeParams({
        rooms: Math.max(10, Math.min(500, parseInt(els.rooms.value, 10) || 100)),
        energy: Math.max(100, Math.min(20000, parseInt(els.energy.value, 10) || 5000)),
        mode: els.mode.value,
        seed: (els.seed.value || "").trim(),
      });
      navigator.clipboard.writeText(url).then(() => {
        els.message.textContent = "Shareable link copied to clipboard!";
      });
    });

    // Init from URL params
    (function init() {
      const params = readParams();
      els.rooms.value = params.rooms;
      els.energy.value = params.energy;
      els.mode.value = params.mode;
      els.seed.value = params.seed;
      buildTrack(params.rooms);
      newGame();
      updateBadges(loadLB());
    })();
  </script>
</body>
</html>
