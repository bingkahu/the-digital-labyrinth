<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Digital Labyrinth — Stable v4</title>
<style>
  :root {
    --bg: #0b0f1a; --panel: #12172b; --panel2: #0f1324;
    --text: #e6e9ff; --muted: #aab0d6; --accent: #6c8cff; --accent2: #ff7a59;
    --good: #3ecf8e; --bad: #ff5c5c; --gold: #ffd166;
  }
  * { box-sizing: border-box; }
  body { margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial; background: var(--bg); color: var(--text); }
  .topbar {
    position: sticky; top: 0; z-index: 20; display: flex; align-items: center; justify-content: space-between;
    padding: 0.6rem 0.8rem; background: linear-gradient(180deg, rgba(108,140,255,0.12), rgba(0,0,0,0));
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .group { display: flex; gap: 0.6rem; align-items: center; flex-wrap: wrap; }
  .brand { font-weight: 700; letter-spacing: 0.2px; }
  button, input, select {
    padding: 0.5rem 0.7rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.12);
    background: var(--panel); color: var(--text);
  }
  button { cursor: pointer; background: linear-gradient(180deg, #1b2140, #12162e); border: 1px solid rgba(108,140,255,0.35); }
  button:hover { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(108,140,255,0.15); }
  .layout {
    display: grid; grid-template-columns: 320px 1fr; gap: 0.8rem; padding: 0.8rem; min-height: calc(100vh - 56px);
  }
  @media (max-width: 900px) { .layout { grid-template-columns: 1fr; } }
  .panel {
    background: var(--panel2); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 0.8rem;
  }
  .panel h3 { margin: 0 0 0.6rem 0; font-size: 16px; color: var(--muted); }
  .controls { display: grid; gap: 0.6rem; }
  .controls .row { display: flex; gap: 0.6rem; flex-wrap: wrap; }
  .big { font-size: 18px; padding: 0.8rem 1rem; }
  .status { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.6rem; }
  .card { background: #0f1324; border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 0.6rem; }
  .bar { height: 12px; border-radius: 999px; background: #0b0e1d; overflow: hidden; border: 1px solid rgba(255,255,255,0.08); }
  .fill { height: 100%; width: 0%; transition: width 0.15s ease; }
  .fill.energy { background: linear-gradient(90deg, var(--good), var(--bad)); }
  .fill.progress { background: linear-gradient(90deg, var(--accent), var(--accent2)); }
  .canvasWrap { position: relative; background: #0b0e1d; border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; overflow: hidden; }
  canvas { display: block; width: 100%; height: 70vh; }
  .overlay {
    position: absolute; inset: 0; display: grid; place-items: center; background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.6));
    opacity: 0; pointer-events: none; transition: opacity 0.2s ease;
  }
  .overlay.show { opacity: 1; pointer-events: auto; }
  .overlay .box {
    background: rgba(18, 23, 43, 0.9); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 1rem; max-width: 560px; text-align: center;
  }
  .overlay h2 { margin: 0 0 0.4rem 0; }
  .overlay p { color: var(--muted); }
  .mobile {
    position: fixed; right: 0.8rem; bottom: 0.8rem; display: flex; gap: 0.6rem; z-index: 30;
  }
  @media (min-width: 900px) { .mobile { display: none; } }
</style>
</head>
<body>
  <div class="topbar">
    <div class="group">
      <div class="brand">Digital Labyrinth — Stable v4</div>
      <button id="btnMenu">Menu</button>
      <button id="btnPlay">Play</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset">Reset</button>
      <button id="btnAuto">Auto</button>
    </div>
    <div class="group">
      <label>Rooms <input type="number" id="rooms" value="100" min="50" max="500" /></label>
      <label>Energy <input type="number" id="energy" value="5000" min="500" max="20000" /></label>
      <label>Mode
        <select id="mode">
          <option value="mercy">Mercy Rule</option>
          <option value="fixed">Fixed 80% Heads</option>
          <option value="insane">Insane</option>
        </select>
      </label>
      <label>Seed <input type="text" id="seed" placeholder="optional" /></label>
      <button id="btnShare">Share</button>
    </div>
  </div>

  <div class="layout">
    <div class="panel">
      <h3>Controls</h3>
      <div class="controls">
        <div class="row">
          <button class="big" id="flipOnce">Flip once</button>
          <button id="flip10">Flip ×10</button>
          <button id="flip100">Flip ×100</button>
          <button id="flip1000">Flip ×1000</button>
        </div>
        <div class="row">
          <button id="dashL">Dash ←</button>
          <button id="dashR">Dash →</button>
          <button id="clearSeed">Clear seed</button>
        </div>
      </div>

      <h3>Status</h3>
      <div class="status">
        <div class="card"><strong>Position:</strong> <span id="pos">1</span> / <span id="posMax">100</span></div>
        <div class="card"><strong>Energy:</strong> <span id="eng">5000</span></div>
        <div class="card"><strong>Fails:</strong> <span id="fails">0</span></div>
        <div class="card"><strong>Heads %:</strong> <span id="pheads">50%</span></div>
        <div class="card"><strong>Flips:</strong> <span id="flips">0</span></div>
        <div class="card"><strong>Combo:</strong> <span id="combo">0</span></div>
        <div class="card"><strong>Streak:</strong> <span id="streak">0</span></div>
        <div class="card"><strong>Power-ups:</strong> <span id="powers">None</span></div>
        <div class="card"><strong>Obstacles:</strong> <span id="obsts">None</span></div>
        <div class="card"><strong>Boss Gate:</strong> <span id="boss">Locked</span></div>
        <div class="card">
          <strong>Progress</strong>
          <div class="bar"><div class="fill progress" id="barProgress"></div></div>
        </div>
        <div class="card">
          <strong>Energy</strong>
          <div class="bar"><div class="fill energy" id="barEnergy"></div></div>
        </div>
      </div>
    </div>

    <div class="panel canvasWrap">
      <canvas id="game"></canvas>
      <div class="overlay show" id="overlay">
        <div class="box">
          <h2>Welcome to the Labyrinth</h2>
          <p>Press <strong>Play</strong> to start. Use <strong>Space</strong> to flip, <strong>←/→</strong> or <strong>A/D</strong> to dash. Or hit the big <strong>Flip once</strong> button.</p>
          <p>Modes: Mercy (pity increases Heads), Fixed (80% Heads, −5 rooms on Tails), Insane (chaos).</p>
          <button id="overlayPlay">Play now</button>
        </div>
      </div>
    </div>
  </div>

  <div class="mobile">
    <button id="mFlip">Flip</button>
    <button id="mDashL">Dash ←</button>
    <button id="mDashR">Dash →</button>
  </div>

<script>
/* ========= RNG ========= */
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;}}
function hashSeed(s){let h=0;for(let i=0;i<s.length;i++){h=(h<<5)-h+s.charCodeAt(i);h|=0;}return h;}

/* ========= Canvas ========= */
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
let W=0,H=0;
function resize(){ const rect=canvas.parentElement.getBoundingClientRect(); W=Math.floor(rect.width); H=Math.floor(Math.max(320, rect.height)); canvas.width=W; canvas.height=H; }
window.addEventListener("resize", resize); resize();

/* ========= Camera ========= */
const Camera={ zoom:1, shakeT:0, shakeMag:0,
  apply(){ ctx.save(); ctx.translate(W/2,H/2); ctx.scale(this.zoom,this.zoom); ctx.translate(-W/2,-H/2);
    if(this.shakeT>0){ this.shakeT-=1/60; ctx.translate((Math.random()-0.5)*this.shakeMag,(Math.random()-0.5)*this.shakeMag); } },
  reset(){ ctx.restore(); },
  shake(m=8,t=0.2){ this.shakeMag=m; this.shakeT=t; },
  zoomTo(z,d=0.3){ const s=this.zoom, diff=z-s, t0=performance.now(); const anim=()=>{ const t=(performance.now()-t0)/(d*1000); if(t>=1){ this.zoom=z; return; } this.zoom=s+diff*(1-Math.pow(1-t,3)); requestAnimationFrame(anim); }; anim(); }
};

/* ========= Game Logic ========= */
class Labyrinth{
  constructor({rooms=100,energy=5000,mode="mercy",seed=null}={}){ this.rooms=rooms; this.energyMax=energy; this.mode=mode; this.seed=seed; this.reset(); }
  reset(){ this.position=1; this.energy=this.energyMax; this.fails=0; this.flips=0; this.done=false; this.win=false;
    this.longestStreak=0; this.currentStreak=0; this.combo=0; this.bossLocked=true; this.gravityActive=false;
    this.powerups=[]; this.obstacles=[]; this.rng=this.seed?mulberry32(hashSeed(this.seed)):Math.random; this.spawnObstacles(); this.spawnPowerups(); }
  get pHeads(){ if(this.mode==="mercy") return Math.min(0.5+0.01*this.fails,1.0); if(this.mode==="fixed") return 0.8; if(this.mode==="insane") return 0.6; return 0.5; }
  spawnObstacles(){ this.obstacles=[ {type:"trap",pos:Math.floor(this.rooms*0.2)}, {type:"trap",pos:Math.floor(this.rooms*0.45)}, {type:"gravity",pos:Math.floor(this.rooms*0.7)} ]; }
  spawnPowerups(){ this.powerups=[ {type:"shield",pos:Math.floor(this.rooms*0.1)}, {type:"turbo",pos:Math.floor(this.rooms*0.35)}, {type:"lucky",pos:Math.floor(this.rooms*0.6)} ]; }
  powerActive(type){ return this.powerups.some(p=>p.pos===-1 && p.type===type); }
  consumePower(type){ const i=this.powerups.findIndex(p=>p.pos===-1 && p.type===type); if(i>=0) this.powerups.splice(i,1); }
  applyPowerups(){ const idx=this.powerups.findIndex(p=>p.pos===this.position); if(idx>=0){ const p=this.powerups.splice(idx,1)[0]; this.powerups.push({type:p.type,pos:-1}); Camera.shake(4,0.1); } }
  applyObstacles(){ const here=this.obstacles.find(o=>o.pos===this.position); if(!here) return;
    if(here.type==="trap"){ if(this.powerActive("shield")) return; Camera.shake(8,0.2);
      if(this.mode==="mercy"){ this.position=1; this.fails++; this.combo=0; this.currentStreak=0; }
      else if(this.mode==="fixed"){ this.position=Math.max(1,this.position-10); this.combo=0; this.currentStreak=0; }
      else { this.position=Math.floor(1+(this.seed?this.rng():Math.random())*this.rooms); this.combo=0; this.currentStreak=0; }
    } else if(here.type==="gravity"){ this.gravityActive=true; } }
  bossCheck(){ if(this.position>=this.rooms){ if(this.bossLocked){ if(this.combo>=10 || this.powerActive("lucky")){ this.bossLocked=false; this.consumePower("lucky"); return true; } else { this.position=this.rooms-1; return false; } } return true; } return false; }
  dash(dir){ if(this.done) return; const cost=5; if(this.energy<cost) return; this.energy-=cost; const step=dir>0?3:-3;
    this.position=Math.max(1,Math.min(this.rooms,this.position+step)); this.applyPowerups(); this.applyObstacles(); if(this.bossCheck()){ this.done=true; this.win=true; } }
  step(){ if(this.done) return; const p=this.pHeads; const r=this.seed?this.rng():Math.random(); this.flips++; this.energy--;
    if(r<p){ this.position++; this.currentStreak++; this.combo++; this.longestStreak=Math.max(this.longestStreak,this.currentStreak); }
    else { this.currentStreak=0; this.combo=0;
      if(this.mode==="mercy"){ this.position=1; this.fails++; }
      else if(this.mode==="fixed"){ const penalty=this.gravityActive?10:5; this.position=Math.max(1,this.position-penalty); }
      else { this.position=Math.floor(1+(this.seed?this.rng():Math.random())*this.rooms); }
      this.gravityActive=false;
    }
    this.applyPowerups(); this.applyObstacles();
    if(this.bossCheck()){ this.done=true; this.win=true; } else if(this.energy<=0){ this.done=true; this.win=false; }
  }
}

/* ========= HUD ========= */
const UI={
  els:{
    rooms:document.getElementById("rooms"), energy:document.getElementById("energy"), mode:document.getElementById("mode"), seed:document.getElementById("seed"),
    pos:document.getElementById("pos"), posMax:document.getElementById("posMax"), eng:document.getElementById("eng"), fails:document.getElementById("fails"),
    pheads:document.getElementById("pheads"), flips:document.getElementById("flips"), combo:document.getElementById("combo"), streak:document.getElementById("streak"),
    barProgress:document.getElementById("barProgress"), barEnergy:document.getElementById("barEnergy"), powers:document.getElementById("powers"), obsts:document.getElementById("obsts"), boss:document.getElementById("boss"),
  },
  updateHUD(){
    const L=Game.labyrinth;
    this.els.pos.textContent=L.position; this.els.posMax.textContent=L.rooms; this.els.eng.textContent=L.energy;
    this.els.fails.textContent=L.fails; this.els.pheads.textContent=`${Math.round(L.pHeads*100)}%`; this.els.flips.textContent=L.flips;
    this.els.combo.textContent=L.combo; this.els.streak.textContent=L.longestStreak;
    this.els.barProgress.style.width=`${(L.position/L.rooms)*100}%`; this.els.barEnergy.style.width=`${(L.energy/L.energyMax)*100}%`;
    const inv=L.powerups.filter(p=>p.pos===-1).map(p=>p.type).join(", ")||"None"; this.els.powers.textContent=inv;
    const obs=L.obstacles.map(o=>`${o.type}@${o.pos}`).join(", ")||"None"; this.els.obsts.textContent=obs;
    this.els.boss.textContent=L.bossLocked?"Locked (10 combo or Lucky Coin)":"Broken — gate open!";
  },
  share(){
    const u=new URL(window.location.href);
    u.searchParams.set("rooms", Game.labyrinth.rooms);
    u.searchParams.set("energy", Game.labyrinth.energyMax);
    u.searchParams.set("mode", Game.labyrinth.mode);
    if(Game.labyrinth.seed) u.searchParams.set("seed", Game.labyrinth.seed);
    navigator.clipboard.writeText(u.toString()).then(()=>console.log("Link copied"));
  }
};

/* ========= Game State ========= */
const Game={ state:"menu", labyrinth:new Labyrinth(), auto:false, dt:0, last:performance.now(),
  update(t){ this.dt=(t-this.last)/1000; this.last=t; if(this.state==="play"){ if(this.auto && !this.labyrinth.done){ this.labyrinth.step(); } if(this.labyrinth.done){ this.state=this.labyrinth.win?"win":"lose"; } } },
  render(){
    ctx.clearRect(0,0,W,H); Camera.apply();
    const margin=24, trackW=W-2*margin, trackH=Math.min(160, Math.max(120, Math.floor(H*0.22))), trackX=margin, trackY=H/2-trackH/2;
    // Track
    ctx.fillStyle="#0f1324"; ctx.fillRect(trackX,trackY,trackW,trackH);
    // Cells
    const cellW=trackW/this.labyrinth.rooms;
    for(let i=0;i<this.labyrinth.rooms;i++){
      const x=trackX+i*cellW, y=trackY;
      const isGoal=(i+1===this.labyrinth.rooms);
      ctx.fillStyle=isGoal?"#1f2546":"#12162e";
      ctx.fillRect(x+2,y+2,cellW-4,trackH-4);
      // Obstacles
      if(this.labyrinth.obstacles.some(o=>o.pos===i+1)){
        ctx.fillStyle="#2a1b1b"; ctx.fillRect(x+cellW/2-8,y+trackH/2-8,16,16);
      }
      // Powerups
      if(this.labyrinth.powerups.some(p=>p.pos===i+1)){
        ctx.fillStyle="#1b2a1b"; ctx.fillRect(x+cellW/2-8,y+trackH/2-8,16,16);
      }
    }
    // Avatar
    const ax=trackX+(this.labyrinth.position-1)*cellW+cellW/2;
    const ay=trackY+trackH/2;
    drawAvatar(ax, ay);
    // Boss gate glow
    drawGoal(trackX+(this.labyrinth.rooms-1)*cellW+cellW/2, trackY+trackH/2, !this.labyrinth.bossLocked);
    // State overlays
    if(Game.state==="menu"){ drawOverlayText("Press Play to start. Space to flip. ←/→ to dash."); }
    if(Game.state==="win"){ drawOverlayText(`VICTORY — Room ${this.labyrinth.rooms} in ${this.labyrinth.flips} flips. Energy left: ${this.labyrinth.energy}.`); }
    if(Game.state==="lose"){ drawOverlayText(`OUT OF ENERGY — Reached Room ${this.labyrinth.position} after ${this.labyrinth.flips} flips.`); }
    Camera.reset();
  }
};

/* ========= Simple visuals (stable) ========= */
function drawAvatar(x,y){
  ctx.save();
  ctx.shadowColor= "#ffd166"; ctx.shadowBlur=18;
  ctx.fillStyle="#ffd166"; ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawGoal(x,y,open){
  ctx.save();
  const g=ctx.createRadialGradient(x,y,10,x,y,60);
  g.addColorStop(0, open?"rgba(62,207,142,0.35)":"rgba(255,209,102,0.35)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,60,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawOverlayText(text){
  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.35)"; ctx.fillRect(0,0,W,H);
  ctx.fillStyle="#e6e9ff"; ctx.font="20px system-ui"; ctx.textAlign="center";
  ctx.fillText(text, W/2, H*0.25);
  ctx.restore();
}

/* ========= Input ========= */
function ensurePlay(){ if(Game.state==="menu"){ Game.state="play"; overlay.classList.remove("show"); } }
window.addEventListener("keydown",(e)=>{
  if(e.code==="Space"){ e.preventDefault(); ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.step(); UI.updateHUD(); }
  if(["ArrowLeft","KeyA"].includes(e.code)){ e.preventDefault(); ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.dash(-1); UI.updateHUD(); }
  if(["ArrowRight","KeyD"].includes(e.code)){ e.preventDefault(); ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.dash(1); UI.updateHUD(); }
  if(e.code==="KeyM"){ Game.state="menu"; overlay.classList.add("show"); }
  if(e.code==="KeyP"){ Game.state=Game.state==="pause"?"play":"pause"; }
  if(e.code==="KeyR"){ Game.labyrinth.reset(); UI.updateHUD(); }
});

/* ========= Buttons ========= */
const overlay=document.getElementById("overlay");
document.getElementById("overlayPlay").addEventListener("click",()=>{ Game.state="play"; overlay.classList.remove("show"); });

document.getElementById("btnMenu").addEventListener("click",()=>{ Game.state="menu"; overlay.classList.add("show"); });
document.getElementById("btnPlay").addEventListener("click",()=>{ Game.state="play"; overlay.classList.remove("show"); });
document.getElementById("btnPause").addEventListener("click",()=>{ Game.state=Game.state==="pause"?"play":"pause"; });
document.getElementById("btnReset").addEventListener("click",()=>{ Game.labyrinth.reset(); UI.updateHUD(); });
document.getElementById("btnAuto").addEventListener("click",()=>{ ensurePlay(); Game.auto=!Game.auto; });

document.getElementById("flipOnce").addEventListener("click",()=>{ ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.step(); UI.updateHUD(); });
document.getElementById("flip10").addEventListener("click",()=>{ ensurePlay(); for(let i=0;i<10 && Game.state==="play" && !Game.labyrinth.done;i++){ Game.labyrinth.step(); } UI.updateHUD(); });
document.getElementById("flip100").addEventListener("click",()=>{ ensurePlay(); for(let i=0;i<100 && Game.state==="play" && !Game.labyrinth.done;i++){ Game.labyrinth.step(); } UI.updateHUD(); });
document.getElementById("flip1000").addEventListener("click",()=>{ ensurePlay(); for(let i=0;i<1000 && Game.state==="play" && !Game.labyrinth.done;i++){ Game.labyrinth.step(); } UI.updateHUD(); });

document.getElementById("dashL").addEventListener("click",()=>{ ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.dash(-1); UI.updateHUD(); });
document.getElementById("dashR").addEventListener("click",()=>{ ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.dash(1); UI.updateHUD(); });

document.getElementById("mFlip").addEventListener("click",()=>{ ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.step(); UI.updateHUD(); });
document.getElementById("mDashL").addEventListener("click",()=>{ ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.dash(-1); UI.updateHUD(); });
document.getElementById("mDashR").addEventListener("click",()=>{ ensurePlay(); if(Game.state!=="play") return; Game.labyrinth.dash(1); UI.updateHUD(); });

document.getElementById("clearSeed").addEventListener("click",()=>{ document.getElementById("seed").value=""; Game.labyrinth.seed=null; Game.labyrinth.reset(); UI.updateHUD(); });

document.getElementById("btnShare").addEventListener("click",()=>UI.share());

document.getElementById("rooms").addEventListener("change",()=>{ const r=parseInt(document.getElementById("rooms").value,10)||100; Game.labyrinth.rooms=Math.max(50,Math.min(500,r)); Game.labyrinth.reset(); UI.updateHUD(); });
document.getElementById("energy").addEventListener("change",()=>{ const e=parseInt(document.getElementById("energy").value,10)||5000; Game.labyrinth.energyMax=Math.max(500,Math.min(20000,e)); Game.labyrinth.reset(); UI.updateHUD(); });
document.getElementById("mode").addEventListener("change",()=>{ Game.labyrinth.mode=document.getElementById("mode").value; Game.labyrinth.reset(); UI.updateHUD(); });
document.getElementById("seed").addEventListener("change",()=>{ const s=(document.getElementById("seed").value||"").trim(); Game.labyrinth.seed=s||null; Game.labyrinth.reset(); UI.updateHUD(); });

/* ========= Init ========= */
(function init(){
  const u=new URL(window.location.href);
  const rooms=parseInt(u.searchParams.get("rooms")||"100",10);
  const energy=parseInt(u.searchParams.get("energy")||"5000",10);
  const mode=u.searchParams.get("mode")||"mercy";
  const seed=u.searchParams.get("seed")||"";
  document.getElementById("rooms").value=rooms;
  document.getElementById("energy").value=energy;
  document.getElementById("mode").value=mode;
  document.getElementById("seed").value=seed;
  Game.labyrinth=new Labyrinth({rooms,energy,mode,seed:seed||null});
  UI.updateHUD();
})();

/* ========= Loop ========= */
function loop(t){ Game.update(t); if(Game.state!=="pause"){ Game.render(); } requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>
